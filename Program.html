<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.8" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="listingblock">
<div class="content">
<pre><code>ï»¿</code></pre>
</div></div>
<div class="sect1">
<h2 id="_background">Background</h2>
<div class="sectionbody">
<div class="paragraph"><p>I like reading old programming books. I was reading
<a href="http://www.amazon.com/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X">The practice of programming</a>
 (from the 80s) when I stumbled into a nice program to generate gibberish text. An example of it, from the bible,
 is below:</p></div>
<div class="paragraph"><p>Israel: put it also is with thy rivers, and over the asses of Zibeon the Hivite; 36:3 And if the thief be found naked. 5:4 For we know that the LORD concerning Jehoiakim the king, except the king may
judge them; then he will take pleasure in the twelfth year, in the brooks of honey and the elders of that place Beersheba; because there is no light in the Jews' enemy. 3:11 And the border were at Bet
hel came forth of my teachers, nor inclined their ear, but walked in the ditch, and mine eyes and mine arm fall from my face, except your brother be waxen poor, and ye visited me: I was astonished at
the time was come near to her own works praise her in an earthen vessel over running water: 14:7 And there arose up a parable unto us, and brought him to the young men are peaceable with us; there sha
ll they that conspired against him, and covered the tabernacle, and it shall be as still as a wild beast of the gold become dim! how is she without, now in thine hand, and in the cities that be with y
ou alway, even unto the coming of the LORD pondereth the hearts.</p></div>
<div class="paragraph"><p>The authors wrote the algorithm in several programming languages and then tested both their performance and how many
lines of code it took to write each one. I decided to bring the example to the modern era.</p></div>
<div class="paragraph"><p>I grabbed the code from <a href="http://cm.bell-labs.com/cm/cs/tpop/code.html">here</a>, made it compile, wrote a perf test
and rewrote it in F# for comparison. Sneak preview below &#8230;</p></div>
<div class="tableblock">
<table rules="rows"
width="40%"
frame="void"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="bottom">           </th>
<th align="right" valign="bottom"> KJ Bible  </th>
<th align="right" valign="bottom"> PSalms</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="bottom"><p class="table header">C</p></td>
<td align="right" valign="bottom"><p class="table">2.51</p></td>
<td align="right" valign="bottom"><p class="table">0.96</p></td>
</tr>
<tr>
<td align="left" valign="bottom"><p class="table header">C++</p></td>
<td align="right" valign="bottom"><p class="table">5.13</p></td>
<td align="right" valign="bottom"><p class="table">1.72</p></td>
</tr>
<tr>
<td align="left" valign="bottom"><p class="table header">Awk</p></td>
<td align="right" valign="bottom"><p class="table">4.56</p></td>
<td align="right" valign="bottom"><p class="table">1.22</p></td>
</tr>
<tr>
<td align="left" valign="bottom"><p class="table header">Perl</p></td>
<td align="right" valign="bottom"><p class="table">2.78</p></td>
<td align="right" valign="bottom"><p class="table">0.90</p></td>
</tr>
<tr>
<td align="left" valign="bottom"><p class="table header">F# (map)</p></td>
<td align="right" valign="bottom"><p class="table">11.42</p></td>
<td align="right" valign="bottom"><p class="table">1.63</p></td>
</tr>
<tr>
<td align="left" valign="bottom"><p class="table header">F# (hash)</p></td>
<td align="right" valign="bottom"><p class="table">2.68</p></td>
<td align="right" valign="bottom"><p class="table">1.03</p></td>
</tr>
<tr>
<td align="left" valign="bottom"><p class="table header">F# (imper)</p></td>
<td align="right" valign="bottom"><p class="table">2.71</p></td>
<td align="right" valign="bottom"><p class="table">0.93</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The algorithm takes a text and divides it into words. It uses the first N words as the start state.
It then looks in the text for all the words following these N words and picks one at random. It then advances
the N words and repeats.</p></div>
<div class="paragraph"><p>It would be odiously inefficient to implement it as such. You really want to do two steps: one to
gather all the prefixes and the other to generate the text. Let&#8217;s see.</p></div>
<div class="listingblock">
<div class="content">
<pre><code></code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_the_code">The code</h2>
<div class="sectionbody">
<div class="paragraph"><p>All of the below values should be parameters to the program &#8230;</p></div>
<div class="listingblock">
<div class="content">
<pre><code>open System.Collections.Generic
open System.Text

let lookback    = 2
let textLenght  = 10000 // words
let delim       = [|' '; '\n'; '\t';'\r'|]

 The following code splits stdin into words **)</code></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><code>let split d (s: string) = s.Split(d)
let readFileWords delim = System.Console.In.ReadToEnd &gt;&gt; split delim &gt;&gt; Seq.filter (fun l -&gt; l &lt;&gt; "")</code></pre>
</div></div>
<div class="paragraph"><p>This is the most interesting part of the code: which data structure to choose to store the prefixes. I did it with
a <code>map</code> first, which causes the large times fo <em>F# (map)</em> that you see above. I then moved to a <code>Dictionary</code>, gaining
most of the performance back. Subsequently I also used a mutable list instead of an immutable one as Tokens,
bringing down the times at par with the C implementation.</p></div>
<div class="paragraph"><p>The reasons for the perf improvements are:
. <code>Dictionary</code> is an hashtable while <code>map</code> is a binary tree. Inserting and looking up is then O(1) instead of O(long n).
. Using a mutable list allows us not to have to remove a list from the hashtable and then add it again, avoiding one lookup and one insert</p></div>
<div class="listingblock">
<div class="content">
<pre><code>type Keys = string list
type Tokens = List&lt;string&gt;
type PlaceCache = Dictionary&lt;Keys, Tokens&gt;

let addToken t (l:Tokens) = l.Add(t); l

let addToDict (dict:PlaceCache) (k, v) =
    let found, values = dict.TryGetValue(k)
    if found then addToken v values |&gt; ignore
             else dict.Add (k, addToken v (Tokens()))
    dict</code></pre>
</div></div>
<div class="paragraph"><p>Build an hash table using the N - 1 items in (a1,&#8230; aN) as key and aN as value. I have the feeling that
<code>Seq.windowed</code> is on the expensive side and could be optimized. But I hit my perf target so I didn&#8217;t optimize
further.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>let splitLastItem a = let n = Array.length a
                      Array.sub a 0 (n - 1) |&gt; Array.toList, Array.get a (n - 1)

let createDict () = readFileWords delim ()
                    |&gt; Seq.windowed (lookback + 1)
                    |&gt; Seq.map splitLastItem
                    |&gt; Seq.fold addToDict (PlaceCache(10000))

 Generic way to pick random elements from an array and list **)</code></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><code>let rnd = System.Random()
let pickRandomArr a = Array.get a (rnd.Next(Array.length a - 1))
let pickRandomToken (l:Tokens) = l |&gt; Seq.nth (rnd.Next(l.Count - 1))

 Pick a prefix that starts with uppercase by looking at all the prefixes **)</code></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><code>let pickRandomBeginning (dict:PlaceCache) = dict.Keys
                                            |&gt; Seq.filter (fun k -&gt; k.[0].[0] |&gt; System.Char.IsUpper)
                                            |&gt; Seq.toArray
                                            |&gt; pickRandomArr
                                            |&gt; List.rev

 This just implements the algorithm described above. It generates N gibberish words.</code></pre>
</div></div>
<div class="paragraph"><p>Again, I have the suspicion that &lt;1&gt; below could be optimized further, but didn&#8217;t investigate.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>let rec generateMarkov beginPicker lenght (dict:PlaceCache) =
    let beginning = dict |&gt; beginPicker
    let n = beginning |&gt; List.length
    [0 .. lenght - 1 - n] // starts from -n because we add n items in one go when []
        |&gt; List.fold (fun state i -&gt;
                        let key = state |&gt; Seq.take n |&gt; List.ofSeq |&gt; List.rev // <b>&lt;1&gt;</b>
                        let values = dict.[key]
                        pickRandomToken values :: state) beginning


 This just accumulate the string. A +StringBuilder+ would be faster,</code></pre>
</div></div>
<div class="paragraph"><p>but it is negligeble compared to the time spent in the tight loops above.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>let accumulateMarkov aSeq = aSeq |&gt; List.fold (fun state x -&gt; x + " " + state) ""

let text = createDict () |&gt; generateMarkov pickRandomBeginning textLenght |&gt; accumulateMarkov

printfn "%s" text</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_comments">Comments</h2>
<div class="sectionbody">
<div class="paragraph"><p>If you look at the performance table above, some things are striking:
. There got to be something wrong with the C++ implementation, it can&#8217;t be so bad
. Perl is very fast for this kind of processing (albeit Perl and Awk are specific to 2 words prefixes)
. Awk is taken from <a href="https://github.com/danfuzz/one-true-awk">here</a> and running on Windows. A better Awk will do better.
. F#, properly optimized, is a fierce competitor in this scenario
. It is unfortunate that you have to get out of the functional paradigm to properly optimize it. But that
  exactly why F# is so powerful. You can do it.</p></div>
<div class="listingblock">
<div class="content">
<pre><code></code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_other_code">Other code</h2>
<div class="sectionbody">
<div class="paragraph"><p>Below is the commented out code for the <em>purely functional</em> version, using <code>map</code>, and the messy imperative one.</p></div>
<div class="listingblock">
<div class="content">
<pre><code></code></pre>
</div></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2013-06-07 16:55:47 GMT Daylight Time
</div>
</div>
</body>
</html>
